// ======================================================================
// myFP2ESP - Firmware for ESP8266 and ESP32 myFocuserPro2 Controllers
// TEST PUSHBUTTONS
// ======================================================================
// Remember to change your target CPU depending on board selection
//
// ======================================================================
// COPYRIGHT
// ======================================================================
// (c) Copyright Robert Brown 2014-2019. All Rights Reserved.
// (c) Copyright Holger M, 2019, who wrote large portions of code for state machine and esp comms
//
// ======================================================================
// CONTRIBUTIONS
// ======================================================================
// If you wish to make a small contribution in thanks for this project, please use PayPal and send the amount
// to user rbb1brown@gmail.com (Robert Brown). All contributions are gratefully accepted.
//

// ======================================================================
// INCLUDES
// ======================================================================
#include "boarddefs.h"                      // include driver board and motor high level definitions
#include "generalDefinitions.h"             // include global definitions
#include "myBoards.h"                       // include driverboard class definitions
#include "focuserconfig.h"

#if defined(ESP8266)                        // generated by Arduino IDE
#undef DEBUG_ESP_HTTP_SERVER                // prevent messages from WiFiServer 
#include <FS.h>                             // include the SPIFFS library  
#else                                       // otherwise assume ESP32
#include "SPIFFS.h"
#endif
#include <SPI.h>
#include "FocuserSetupData.h"

// ======================================================================
// OVERVIEW: TO PROGRAM THE FIRMWARE
// ======================================================================
// 1. Set your DRVBRD in focuserconfig.h so the correct driver board is used
// 2. For specific boards set the FIXEDSTEPMODE in focuserconfig.h
// 3. For specific boards set the STEPSPERREVOLUTION in focuserconfig.h
// 4. Enable Display type [if fitted[ in focuserconfig.h
// 7. Set your target CPU to match the correct CPU for your board
// 8. Compile and upload to your controller
// 9. Upload the sketch data files

volatile bool timerSemaphore = false;       // move completed=true, still moving or not moving = false;
volatile uint32_t stepcount;                // number of steps to go in timer interrupt service routine
volatile bool halt_alert;
#if defined(ESP8266)
// in esp8266, volatile data_type varname is all that is needed
#else
// in esp32, we should use a Mutex for access
portMUX_TYPE  timerSemaphoreMux = portMUX_INITIALIZER_UNLOCKED; // shared vars in interrupt routines must control access via mutex
portMUX_TYPE  stepcountMux = portMUX_INITIALIZER_UNLOCKED;
portMUX_TYPE  halt_alertMux = portMUX_INITIALIZER_UNLOCKED;
#endif

DriverBoard   *driverboard;
SetupData     *mySetupData;                 // focuser data

unsigned long ftargetPosition;              // target position

byte TimeCheck(unsigned long x, unsigned long Delay)
{
  unsigned long y = x + Delay;
  unsigned long z = millis();                           // pick current time

  if ((x > y) && (x < z))
    return 0;                                           // overflow y
  if ((x < y) && ( x > z))
    return 1;                                           // overflow z

  return (y < z);                                       // no or (z and y) overflow
}

// ======================================================================
// PUSHBUTTONS - CHANGE AT YOUR OWN PERIL
// ======================================================================
bool init_pushbuttons(void)
{
  //Setup_DebugPrint("initPB: ");
  if ( (mySetupData->get_brdpb1pin() != -1) && (mySetupData->get_brdpb2pin() != -1) )
  {
    // Basic assumption rule: If associated pin is -1 then cannot set enable
    pinMode(mySetupData->get_brdpb1pin(), INPUT);
    pinMode(mySetupData->get_brdpb2pin(), INPUT);
    Serial.println("Push buttons enabled");
    return true;
  }
  else
  {
    Serial.println("Board definition has push button pins set to -1");
  }
  return false;
}

void update_pushbuttons(void)
{
  // PB are active high - pins are low by virtue of oull down resistors through J16 and J17 jumpers
  // read from the board pin number, and compare the return pin value - if 1 then button is pressed
  if ( digitalRead(mySetupData->get_brdpb1pin()) == 1 )
  {
    Serial.println("PB1 pressed");
  }
  if ( digitalRead(mySetupData->get_brdpb2pin()) == 1 )
  {
    Serial.println("PB2 pressed");
  }
}

void setup()
{
  Serial.begin(SERIALPORTSPEED);

  varENTER_CRITICAL(&halt_alertMux);
  halt_alert = false;
  varEXIT_CRITICAL(&halt_alertMux);

  // Setup controller values
  Serial.println("setup(): mySetupData()");
  mySetupData = new SetupData();                // instantiate object SetUpData with SPIFFS file

  Serial.println("driver board: start");
  ftargetPosition = mySetupData->get_fposition();
  driverboard = new DriverBoard( mySetupData->get_fposition() );
  Serial.println("driver board: end");

  // Setup Pushbuttons, active high when pressed
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  bool result = init_pushbuttons();
  Serial.print("Push Buttons: ");
  if ( result == true )
  {
    Serial.println("enabled");
  }
  else
  {
    Serial.println("disabled");
  }
}

//_____________________ loop()___________________________________________

void loop()
{
  update_pushbuttons();
}
