// ======================================================================
// myFP2ESP - Firmware for ESP8266 and ESP32 myFocuserPro2 Controllers
// TEST TEMPERATURE PROBE
// ======================================================================
// Remember to change your target CPU depending on board selection
//
// ======================================================================
// COPYRIGHT
// ======================================================================
// (c) Copyright Robert Brown 2014-2019. All Rights Reserved.
// (c) Copyright Holger M, 2019, who wrote large portions of code for state machine and esp comms
//
// ======================================================================
// CONTRIBUTIONS
// ======================================================================
// If you wish to make a small contribution in thanks for this project, please use PayPal and send the amount
// to user rbb1brown@gmail.com (Robert Brown). All contributions are gratefully accepted.
//

// ======================================================================
// INCLUDES
// ======================================================================
#include "boarddefs.h"                      // include driver board and motor high level definitions
#include "generalDefinitions.h"             // include global definitions
#include "myBoards.h"                       // include driverboard class definitions
#include "focuserconfig.h"

#if defined(ESP8266)                        // generated by Arduino IDE
#undef DEBUG_ESP_HTTP_SERVER                // prevent messages from WiFiServer 
#include <FS.h>                             // include the SPIFFS library  
#else                                       // otherwise assume ESP32
#include "SPIFFS.h"
#endif
#include <SPI.h>
#include "FocuserSetupData.h"

// ======================================================================
// OVERVIEW: TO PROGRAM THE FIRMWARE
// ======================================================================
// 1. Set your DRVBRD in focuserconfig.h so the correct driver board is used
// 2. For specific boards set the FIXEDSTEPMODE in focuserconfig.h
// 3. For specific boards set the STEPSPERREVOLUTION in focuserconfig.h
// 4. Enable Display type [if fitted[ in focuserconfig.h
// 7. Set your target CPU to match the correct CPU for your board
// 8. Compile and upload to your controller
// 9. Upload the sketch data files

volatile bool timerSemaphore = false;       // move completed=true, still moving or not moving = false;
volatile uint32_t stepcount;                // number of steps to go in timer interrupt service routine
volatile bool halt_alert;
#if defined(ESP8266)
// in esp8266, volatile data_type varname is all that is needed
#else
// in esp32, we should use a Mutex for access
portMUX_TYPE  timerSemaphoreMux = portMUX_INITIALIZER_UNLOCKED; // shared vars in interrupt routines must control access via mutex
portMUX_TYPE  stepcountMux = portMUX_INITIALIZER_UNLOCKED;
portMUX_TYPE  halt_alertMux = portMUX_INITIALIZER_UNLOCKED;
#endif

DriverBoard   *driverboard;
SetupData     *mySetupData;                 // focuser data

unsigned long ftargetPosition;              // target position

#include "temp.h"
TempProbe *myTempProbe;
int     tprobe1;                            // true if a temperature probe was detected
float   lasttemp;                           // last valid temp reading

byte TimeCheck(unsigned long x, unsigned long Delay)
{
  unsigned long y = x + Delay;
  unsigned long z = millis();               // pick current time

  if ((x > y) && (x < z))
    return 0;                               // overflow y
  if ((x < y) && ( x > z))
    return 1;                               // overflow z

  return (y < z);                           // no or (z and y) overflow
}

void setup()
{
  Serial.begin(SERIALPORTSPEED);

  varENTER_CRITICAL(&halt_alertMux);
  halt_alert = false;
  varEXIT_CRITICAL(&halt_alertMux);

  // Setup controller values
  Serial.println("setup(): mySetupData()");
  mySetupData = new SetupData();                // instantiate object SetUpData with SPIFFS file

  Serial.println("driver board: start");
  ftargetPosition = mySetupData->get_fposition();
  driverboard = new DriverBoard( mySetupData->get_fposition() );
  Serial.println("driver board: end");

  Serial.println("Start temperature sensor");
  // Setup temperature probe
  tprobe1 = 0;
  lasttemp = 20.0;
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  Serial.print("Temp probe:");
  // In this test code the default is for tempprobe to be enabled
  if ( mySetupData->get_temperatureprobestate() == 1)   // if temperature probe enabled then try to start new probe
  {
    Setup_DebugPrintln("enabled");
    myTempProbe = new TempProbe;                        // create temp probe - should set tprobe1=true if probe found
  }
  else
  {
    tprobe1 = 0;
    Setup_DebugPrintln("disabled");
  }

  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_temperatureprobestate() == 1)     // if temp probe "enabled" state
  {
    if ( tprobe1 != 0 )                                   // if a probe was found
    {
      Setup_DebugPrintln("tprobe1 != 0. read_temp");
      myTempProbe->read_temp(1);                          // read the temperature
    }
    else
    {
      Setup_DebugPrintln("tprobe1 is 0");
      // disable temperature probe
      mySetupData->set_temperatureprobestate(0);
    }
  }
  delay(1000);
}

//_____________________ loop()___________________________________________

void loop()
{
  if ( mySetupData->get_temperatureprobestate() == 1)           // if probe is enabled
  {
    if ( tprobe1 != 0 )                                         // if probe was found
    {
      DebugPrintln("tprobe1 = 1");
      DebugPrintln("update_temp()");
      myTempProbe->update_temp();
      Serial.print("Temp: ");
      Serial.println(lasttemp, 2);
    }
    else
    {
      DebugPrintln("tprobe1 = 0");
    }
  }
  delay(1000);
}
