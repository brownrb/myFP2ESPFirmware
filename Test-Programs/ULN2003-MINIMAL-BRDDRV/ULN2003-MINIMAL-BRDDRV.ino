// ======================================================================
// myFP2ESP - Firmware for ESP8266 and ESP32 myFocuserPro2 Controllers
// TEST ULN2003
// ======================================================================
// Remember to change your target CPU depending on board selection
//
// ======================================================================
// COPYRIGHT
// ======================================================================
// (c) Copyright Robert Brown 2014-2019. All Rights Reserved.
// (c) Copyright Holger M, 2019, who wrote large portions of code for state machine and esp comms
//
// ======================================================================
// CONTRIBUTIONS
// ======================================================================
// If you wish to make a small contribution in thanks for this project, please use PayPal and send the amount
// to user rbb1brown@gmail.com (Robert Brown). All contributions are gratefully accepted.
//

// ======================================================================
// INCLUDES
// ======================================================================
#include "boarddefs.h"                      // include driver board and motor high level definitions
#include "generalDefinitions.h"             // include global definitions
#include "myBoards.h"                       // include driverboard class definitions
#include "focuserconfig.h"

#if defined(ESP8266)                        // generated by Arduino IDE
#undef DEBUG_ESP_HTTP_SERVER                // prevent messages from WiFiServer 
#include <FS.h>                             // include the SPIFFS library  
#else                                       // otherwise assume ESP32
#include "SPIFFS.h"
#endif
#include <SPI.h>
#include "FocuserSetupData.h"

// ======================================================================
// OVERVIEW: TO PROGRAM THE FIRMWARE
// ======================================================================
// 1. Set your DRVBRD in focuserconfig.h so the correct driver board is used
// 2. For specific boards set the FIXEDSTEPMODE in focuserconfig.h
// 3. For specific boards set the STEPSPERREVOLUTION in focuserconfig.h
// 7. Set your target CPU to match the correct CPU for your board
// 8. Compile and upload to your controller
// 9. Upload the sketch data files

// ======================================================================
// GLOBAL DATA -- DO NOT CHANGE
// ======================================================================
volatile bool timerSemaphore = false;       // move completed=true, still moving or not moving = false;
volatile uint32_t stepcount;                // number of steps to go in timer interrupt service routine
volatile bool halt_alert;
#if defined(ESP8266)
// in esp8266, volatile data_type varname is all that is needed
#else
// in esp32, we should use a Mutex for access
portMUX_TYPE  timerSemaphoreMux = portMUX_INITIALIZER_UNLOCKED; // shared vars in interrupt routines must control access via mutex
portMUX_TYPE  stepcountMux = portMUX_INITIALIZER_UNLOCKED;
portMUX_TYPE  halt_alertMux = portMUX_INITIALIZER_UNLOCKED;
#endif

DriverBoard   *driverboard;
SetupData     *mySetupData;                 // focuser data

unsigned long ftargetPosition;              // target position

byte TimeCheck(unsigned long x, unsigned long Delay)
{
  unsigned long y = x + Delay;
  unsigned long z = millis();               // pick current time

  if ((x > y) && (x < z))
    return 0;                               // overflow y
  if ((x < y) && ( x > z))
    return 1;                               // overflow z

  return (y < z);                           // no or (z and y) overflow
}

// move motor without updating position, used by sethomeposition
void steppermotormove(byte ddir )               // direction moving_in, moving_out ^ reverse direction
{
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_inoutledstate() == 1)
  {
    ( ddir == moving_in ) ? digitalWrite(mySetupData->get_brdinledpin(), 1) : digitalWrite(mySetupData->get_brdoutledpin(), 1);
  }
  driverboard->movemotor(ddir, false);
  if ( mySetupData->get_inoutledstate() == 1)
  {
    ( ddir == moving_in ) ? digitalWrite(mySetupData->get_brdinledpin(), 0) : digitalWrite(mySetupData->get_brdoutledpin(), 0);
  }
}

void setup()
{
  Serial.begin(SERIALPORTSPEED);

  // Setup controller values
  Serial.println("setup(): mySetupData()");
  mySetupData = new SetupData();                // instantiate object SetUpData with SPIFFS file

  // Setup Driverboard
  Serial.print("Start drvbrd:");
  Serial.println(DRVBRD);
  // ensure targetposition will be same as focuser position
  // otherwise after loading driverboard focuser will start moving immediately
  Serial.println("driver board: start");
  ftargetPosition = 5000;
  driverboard = new DriverBoard( 5000 );
  Serial.println("driver board: end");

  // ensure driverboard position is same as setupData
  // set focuser position in DriverBoard
  driverboard->setposition(mySetupData->get_fposition());
  mySetupData->set_motorspeed(2);
  // 1. Set mySetupData->set_brdstepmode(xx);       // this saves config setting
  // 2. Set driverboard->setstepmode(xx);           // this sets the physical pins
  mySetupData->set_brdstepmode(1);
  driverboard->setstepmode(1);
}

void loop()
{
  Serial.print("Move motor 200 steps");
  int steps = 200;
  driverboard->initmove(true, steps);
  // wait for move to complete
  while ( timerSemaphore == false )
    ;
  Serial.println("Move completed");
  delay(2000);
  
  Serial.print("Move motor 200 steps reverse");
  steps = 200;
  driverboard->initmove(false, steps);
  // wait for move to complete
  while ( timerSemaphore == false )
    ;
  delay(2000);

} // end Loop()
