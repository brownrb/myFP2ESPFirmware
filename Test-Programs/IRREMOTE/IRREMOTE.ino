// myFP2ESP - Firmware for ESP8266 and ESP32 myFocuserPro2 Controllers
// IRREMOTE Test Program [ESP32]

// USE THE LIBRARY IN THE Library Files folder of the Firmware Zip file
// myfp2eIRremoteESP8266.Zip
//
// THEN INSTALL LIBRARY FROM IDE-Sketch-Include Library-Add ZIP library

// This test program assumes you are using the recommended IR Remote
// ONLY THE SUGGESTED HX1838NEX REMOTE CONTROLLER IS SUPPORTED
// https://www.ebay.com/itm/HX1838-NEC-Code-Infrared-Remote-Control-module-DIY-KitNEW/251895571659

// if you are using a different IRRemote, it may not work.
// But you can use this program to find out the codes generated by a different IR Remote
// and then insert those codes into the irremotemappings.h file

// ======================================================================
// INCLUDES
// ======================================================================
#include <Arduino.h>
#include "boarddefs.h"                      // include driver board and motor high level definitions
#include "generalDefinitions.h"             // include global definitions
#include "myBoards.h"                       // include driverboard class definitions
#include "focuserconfig.h"

#include "SPIFFS.h"
#include <SPI.h>
#include "FocuserSetupData.h"

// ======================================================================
// 1: SPECIFY DRIVER BOARD in 1: focuserconfig.h
// ======================================================================
// Please specify your driver board [DRVBRD] in focuserconfig.h

// ======================================================================
// 2: SPECIFY FIXEDSTEPMODE in 2: focuserconfig.h
// ======================================================================
// For specific boards, specify the correct FIXEDSTEPMODE focuserconfig.h

// ======================================================================
// 3: SPECIFY STEPSPERREVOLUTION in 3: focuserconfig.h
// ======================================================================
// For specific boards, specify the correct STEPSPERREVOLUTION focuserconfig.h

volatile bool timerSemaphore = false;       // move completed=true, still moving or not moving = false;
volatile uint32_t stepcount;                // number of steps to go in timer interrupt service routine
volatile bool halt_alert;
#if defined(ESP8266)
// in esp8266, volatile data_type varname is all that is needed
#else
// in esp32, we should use a Mutex for access
portMUX_TYPE  timerSemaphoreMux = portMUX_INITIALIZER_UNLOCKED; // shared vars in interrupt routines must control access via mutex
portMUX_TYPE  stepcountMux = portMUX_INITIALIZER_UNLOCKED;
portMUX_TYPE  halt_alertMux = portMUX_INITIALIZER_UNLOCKED;
#endif

DriverBoard   *driverboard;
SetupData     *mySetupData;                           // focuser data
unsigned long ftargetPosition;              // target position
bool    irremotestate;

// ======================================================================
// INFRARED REMOTE CONTROLLER - CHANGE AT YOUR OWN PERIL
// ======================================================================

#include <myfp2eIRremoteESP8266.h>                    // use cut down version to save spave
#include <myfp2eIRrecv.h>                             // unable to turn off all options by using a define
#include <myfp2eIRutils.h>
#include "irremotemappings.h"
const uint16_t RECV_PIN = 15;
IRrecv         *irrecv;
decode_results results;


void update_irremote()
{
  if ( irremotestate == true )
  {
    // check IR
    if (irrecv->decode(&results))
    {
      static long lastcode;
      if ( results.value == KEY_REPEAT )
      {
        Serial.print("repeat code: ");
        Serial.println(lastcode);
      }
      else
      {
        Serial.print("Code: ");
        Serial.print(results.value);
        lastcode = results.value;
      }
      switch ( lastcode )
      {
        case IR_SLOW:
          Serial.println("Slow");
          break;
        case IR_MEDIUM:
          Serial.println("Medium");
          break;
        case IR_FAST:
          Serial.println("Fast");
          break;
        case IR_IN1:
          Serial.println("In 1 step");
          break;
        case IR_OUT1:
          Serial.println("Out 1 step");
          break;
        case IR_IN10:
          Serial.println("In 10 steps");
          break;
        case IR_OUT10:
          Serial.println("Out 10 steps");
          break;
        case IR_IN50:
          Serial.println("In 50 steps");
          break;
        case IR_OUT50:
          Serial.println("Out 50 steps");
          break;
        case IR_IN100:
          Serial.println("In 100 steps");
          break;
        case IR_OUT100:
          Serial.println("Out 100 steps");
          break;
        case IR_SETPOSZERO:                         // 0 RESET POSITION TO 0
          Serial.println("Set position to 0");
          break;
        case IR_PRESET0:
          Serial.println("Preset 0");
          break;
        case IR_PRESET1:
          Serial.println("Preset 1");
          break;
        case IR_PRESET2:
          Serial.println("Preset 2");
          break;
        case IR_PRESET3:
          Serial.println("Preset 3");
          break;
        case IR_PRESET4:
          Serial.println("Preset 4");
          break;
      } // switch(lastcode)
      irrecv->resume();                              // Receive the next value
    }
  }
  else
  {
    Serial.println("Cannot start irremote: board pin is -1");
  }
}

void init_irremote(void)
{
  Serial.println("init_irremote");
  irremotestate = false;
  if ( mySetupData->get_brdirpin() != -1 )
  {
    irrecv = new IRrecv(mySetupData->get_brdirpin());
    irrecv->enableIRIn();                            // Start the IR
    irremotestate = true;
  }
  else
  {
    Serial.println("Cannot start irremote: board pin is -1");
    irremotestate = false;
  }
}

void setup()
{
  Serial.begin(SERIALPORTSPEED);
  Serial.println("started serial port");

  Setup_DebugPrintln("setup(): mySetupData()");
  mySetupData = new SetupData();                // instantiate object SetUpData with SPIFFS file

  delay(20);

  Setup_DebugPrintln("driver board: start");
  ftargetPosition = mySetupData->get_fposition();
  driverboard = new DriverBoard( mySetupData->get_fposition() );
  Setup_DebugPrintln("driver board: end");

  delay(20);

  Serial.println("Start IR");
  // Setup infra red remote
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_brdirpin() != 1)
  {
    Serial.println("ir-remote enabled");
    init_irremote();
  }
  else
  {
    Serial.println("ir-remote pin disabled");
  }
  Serial.println("End setup");
}

//_____________________ loop()___________________________________________

void loop()
{
  update_irremote();
  delay(200);
}
