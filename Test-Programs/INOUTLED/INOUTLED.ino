// myFP2ESP - Firmware for ESP8266 and ESP32 myFocuserPro2 Controllers
// IN OUT LED TEST [ESP32 ONLY]
//
// (c) Copyright Robert Brown 2014-2019. All Rights Reserved.
// (c) Copyright Holger M, 2019, who wrote large portions of code for state machine and esp comms
//
// CONTRIBUTIONS
// If you wish to make a small contribution in thanks for this project, please use PayPal and send the amount
// to user rbb1brown@gmail.com (Robert Brown). All contributions are gratefully accepted.
//
// 1. Set your CHIPMODEL [section 1] based on selected chipType matching your PCB
// 2. Set your DRVBRD [section 2] in this file so the correct driver board is used
// 3. Set your target CPU to match the chipModel you defined
// 4. Set the correct hardware options [section 4] in this file to match your hardware
// 5. Compile and upload to your controller
//
// ======================================================================
// SPECIAL LICENSE
// ======================================================================
// This code is released under license. If you copy or write new code based
// on the code in these files, you MUST include a link to these files AND
// you MUST include references to the authors of this code.

// ======================================================================
// CONTRIBUTIONS
// ======================================================================
// It is costly to continue development and purchase boards and components.
// Your support is needed to continue development of this project. Please
// contribute to this project, and use PayPal to send your donation to user
// rbb1brown@gmail.com (Robert Brown). All contributions are gratefully accepted.

#include "boarddefs.h"                      // include driver board and motor high level definitions
#include "generalDefinitions.h"             // include global definitions
#include "myBoards.h"                       // include driverboard class definitions
#include "focuserconfig.h"

// ======================================================================
// INCLUDES
// ======================================================================

#undef DEBUG_ESP_HTTP_SERVER                // needed sometimes to prevent serial output from WiFiServerlibrary

#if defined(ESP8266)                        // generated by Arduino IDE
#undef DEBUG_ESP_HTTP_SERVER                // prevent messages from WiFiServer 
#include <FS.h>                             // include the SPIFFS library  
#else                                       // otherwise assume ESP32
#include "SPIFFS.h"
#endif
#include <SPI.h>
#include "FocuserSetupData.h"

// ======================================================================
// OVERVIEW: TO PROGRAM THE FIRMWARE
// ======================================================================
// 1. Set your DRVBRD in focuserconfig.h so the correct driver board is used
// 2. For specific boards set the FIXEDSTEPMODE in focuserconfig.h
// 3. For specific boards set the STEPSPERREVOLUTION in focuserconfig.h
// 4. Set your target CPU to match the correct CPU for your board
// 5. Compile and upload to your controller
// 6. Upload the sketch data files

// ======================================================================
// 1: SPECIFY DRIVER BOARD in 1: focuserconfig.h
// ======================================================================
// Please specify your driver board [DRVBRD] in focuserconfig.h

// ======================================================================
// 2: SPECIFY FIXEDSTEPMODE in 2: focuserconfig.h
// ======================================================================
// For specific boards, specify the correct FIXEDSTEPMODE focuserconfig.h

// ======================================================================
// 3: SPECIFY STEPSPERREVOLUTION in 3: focuserconfig.h
// ======================================================================
// For specific boards, specify the correct STEPSPERREVOLUTION focuserconfig.h

// ======================================================================
// FIRMWARE CODE START - INCLUDES AND LIBRARIES
// ======================================================================

// ======================================================================
// GLOBAL DATA -- DO NOT CHANGE
// ======================================================================

//           reversedirection
//__________________________________
//               0   |   1
//__________________________________
//moving_out  1||  1   |   0
//moving_in   0||  0   |   1

volatile bool timerSemaphore = false;       // move completed=true, still moving or not moving = false;
volatile uint32_t stepcount;                // number of steps to go in timer interrupt service routine
volatile bool halt_alert;
#if defined(ESP8266)
// in esp8266, volatile data_type varname is all that is needed
#else
// in esp32, we should use a Mutex for access
portMUX_TYPE  timerSemaphoreMux = portMUX_INITIALIZER_UNLOCKED; // shared vars in interrupt routines must control access via mutex
portMUX_TYPE  stepcountMux = portMUX_INITIALIZER_UNLOCKED;
portMUX_TYPE  halt_alertMux = portMUX_INITIALIZER_UNLOCKED;
#endif

DriverBoard   *driverboard;
SetupData     *mySetupData;                 // focuser data

unsigned long ftargetPosition;              // target position
byte    isMoving;                           // is the motor currently moving

// ======================================================================
// FIRMWARE - CHANGE AT YOUR OWN PERIL
// ======================================================================
byte TimeCheck(unsigned long x, unsigned long Delay)
{
  unsigned long y = x + Delay;
  unsigned long z = millis();                           // pick current time

  if ((x > y) && (x < z))
    return 0;                                           // overflow y
  if ((x < y) && ( x > z))
    return 1;                                           // overflow z

  return (y < z);                                       // no or (z and y) overflow
}

// move motor without updating position, used by sethomeposition
void steppermotormove(byte ddir )               // direction moving_in, moving_out ^ reverse direction
{
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_inoutledstate() == 1)
  {
    ( ddir == moving_in ) ? digitalWrite(mySetupData->get_brdinledpin(), 1) : digitalWrite(mySetupData->get_brdoutledpin(), 1);
  }
  driverboard->movemotor(ddir, false);
  if ( mySetupData->get_inoutledstate() == 1)
  {
    ( ddir == moving_in ) ? digitalWrite(mySetupData->get_brdinledpin(), 0) : digitalWrite(mySetupData->get_brdoutledpin(), 0);
  }
}

bool init_leds()
{
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  Setup_DebugPrintln("initleds");
  if ( mySetupData->get_brdinledpin() != -1 )
  {
    pinMode(mySetupData->get_brdinledpin(), OUTPUT);
    digitalWrite(mySetupData->get_brdinledpin(), 0);
  }
  else
  {
    Serial.println("In led pin not defined");
    return false;
  }
  if ( mySetupData->get_brdoutledpin() != -1 )
  {
    pinMode(mySetupData->get_brdoutledpin(), OUTPUT);
    digitalWrite(mySetupData->get_brdoutledpin(), 0);
  }
  else
  {
    Serial.println("Out led pin not defined");
    return false;
  }
  return true;
}

void setup()
{
  //Serial.begin(115200);

#if (CONTROLLERMODE == LOCALSERIAL)
  Serial.begin(SERIALPORTSPEED);
#endif // #if (CONTROLLERMODE == LOCALSERIAL)

  delay(100);                                   // go on after statement does appear

  varENTER_CRITICAL(&halt_alertMux);
  halt_alert = false;
  varEXIT_CRITICAL(&halt_alertMux);

  // Setup controller values
  Serial.println("setup(): mySetupData()");
  mySetupData = new SetupData();                // instantiate object SetUpData with SPIFFS file

  // Setup Driverboard
  Serial.print("Start drvbrd:");
  Serial.println(DRVBRD);
  // ensure targetposition will be same as focuser position
  // otherwise after loading driverboard focuser will start moving immediately
  Serial.println("driver board: start");
  ftargetPosition = mySetupData->get_fposition();
  driverboard = new DriverBoard( mySetupData->get_fposition() );
  Serial.println("driver board: end");
  delay(5);

  Serial.print("IN OUT LEDS");
  bool result = init_leds();
  if ( result == true )
  {
    Serial.println(" enabled");
  }
  else
  {
    Serial.println(" disabled");
  }

  delay(5);

  isMoving = 0;

  // Basic assumption rule: If associated pin is -1 then cannot set enable
  // turn leds off
  if ( mySetupData->get_inoutledstate() == 1)
  {
    digitalWrite(mySetupData->get_brdinledpin(), 0);
    digitalWrite(mySetupData->get_brdoutledpin(), 0);
  }
}

//_____________________ loop()___________________________________________

void loop()
{

  Serial.println("Both LEDs OFF");
  digitalWrite(mySetupData->get_brdinledpin(), 0);
  digitalWrite(mySetupData->get_brdoutledpin(), 0);
  delay(2000);
  Serial.println("IN LED ON");
  Serial.println("OUT LED OFF");
  digitalWrite(mySetupData->get_brdinledpin(), 1);
  digitalWrite(mySetupData->get_brdoutledpin(), 0);
  delay(2000);
  Serial.println("IN LED OFF");
  Serial.println("OUT LED ON");
  digitalWrite(mySetupData->get_brdinledpin(), 0);
  digitalWrite(mySetupData->get_brdoutledpin(), 1);
  delay(2000);
  Serial.println("IN LED ON");
  Serial.println("OUT LED ON");
  digitalWrite(mySetupData->get_brdinledpin(), 1);
  digitalWrite(mySetupData->get_brdoutledpin(), 1);
  delay(2000);

} // end Loop()
