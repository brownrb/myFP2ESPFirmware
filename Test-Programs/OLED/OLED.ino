// ======================================================================
// myFP2ESP - Firmware for ESP8266 and ESP32 myFocuserPro2 Controllers
// TEST FOR OLED DISPLAY
// ======================================================================
//
// ======================================================================
// COPYRIGHT
// ======================================================================
// (c) Copyright Robert Brown 2014-2019. All Rights Reserved.
// (c) Copyright Holger M, 2019, who wrote large portions of code for state machine and esp comms
//
// ======================================================================
// CONTRIBUTIONS
// ======================================================================
// It is costly to continue development and purchase boards and components.
// Your support is needed to continue development of this project. Please
// contribute to this project, and use PayPal to send your donation to user
// rbb1brown@gmail.com (Robert Brown). All contributions are gratefully accepted.
//
//
// ======================================================================
// INCLUDES
// ======================================================================
#include "boarddefs.h"                      // include driver board and motor high level definitions
#include "generalDefinitions.h"             // include global definitions
#include "myBoards.h"                       // include driverboard class definitions
#include "focuserconfig.h"

#if defined(ESP8266)                        // generated by Arduino IDE
#undef DEBUG_ESP_HTTP_SERVER                // prevent messages from WiFiServer 
#include <FS.h>                             // include the SPIFFS library  
#else                                       // otherwise assume ESP32
#include "SPIFFS.h"
#endif
#include <SPI.h>
#include "FocuserSetupData.h"

// ======================================================================
// OVERVIEW: TO PROGRAM THE FIRMWARE
// ======================================================================
// 1. Set your DRVBRD in focuserconfig.h so the correct driver board is used
// 2. For specific boards set the FIXEDSTEPMODE in focuserconfig.h
// 3. For specific boards set the STEPSPERREVOLUTION in focuserconfig.h
// 4. Enable Display type [if fitted[ in focuserconfig.h
// 7. Set your target CPU to match the correct CPU for your board
// 8. Compile and upload to your controller
// 9. Upload the sketch data files

#include "displays.h"
OLED_NON *myoled;

volatile bool timerSemaphore = false;       // move completed=true, still moving or not moving = false;
volatile uint32_t stepcount;                // number of steps to go in timer interrupt service routine
volatile bool halt_alert;
#if defined(ESP8266)
// in esp8266, volatile data_type varname is all that is needed
#else
// in esp32, we should use a Mutex for access
portMUX_TYPE  timerSemaphoreMux = portMUX_INITIALIZER_UNLOCKED; // shared vars in interrupt routines must control access via mutex
portMUX_TYPE  stepcountMux = portMUX_INITIALIZER_UNLOCKED;
portMUX_TYPE  halt_alertMux = portMUX_INITIALIZER_UNLOCKED;
#endif

DriverBoard   *driverboard;
SetupData     *mySetupData;                 // focuser data

unsigned long ftargetPosition;              // target position
bool    displayfound;
byte    isMoving;                           // is the motor currently moving
bool    displaystate;                       // true if a display was found

byte TimeCheck(unsigned long x, unsigned long Delay)
{
  unsigned long y = x + Delay;
  unsigned long z = millis();                           // pick current time

  if ((x > y) && (x < z))
    return 0;                                           // overflow y
  if ((x < y) && ( x > z))
    return 1;                                           // overflow z

  return (y < z);                                       // no or (z and y) overflow
}

// move motor without updating position, used by sethomeposition
void steppermotormove(byte ddir )               // direction moving_in, moving_out ^ reverse direction
{
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_inoutledstate() == 1)
  {
    ( ddir == moving_in ) ? digitalWrite(mySetupData->get_brdinledpin(), 1) : digitalWrite(mySetupData->get_brdoutledpin(), 1);
  }
  driverboard->movemotor(ddir, false);
  if ( mySetupData->get_inoutledstate() == 1)
  {
    ( ddir == moving_in ) ? digitalWrite(mySetupData->get_brdinledpin(), 0) : digitalWrite(mySetupData->get_brdoutledpin(), 0);
  }
}


void setup()
{
  Serial.begin(SERIALPORTSPEED);

  varENTER_CRITICAL(&halt_alertMux);
  halt_alert = false;
  varEXIT_CRITICAL(&halt_alertMux);

  // Setup controller values
  Serial.println("setup(): mySetupData()");
  mySetupData = new SetupData();                // instantiate object SetUpData with SPIFFS file

  Serial.println("driver board: start");
  ftargetPosition = mySetupData->get_fposition();
  driverboard = new DriverBoard( mySetupData->get_fposition() );
  Serial.println("driver board: end");

  // Setup display
  displayfound = false;
#if defined(OLED_MODE)
  if (CheckOledConnected())
  {
    Setup_DebugPrintln("init OLED_MODE");
    myoled = new OLED_MODE;                       // Start configured OLED display object
    displaystate = true;
  }
  else
  {
    Setup_DebugPrintln("init OLED_NON");
    myoled = new OLED_NON;
    displaystate = false;
  }
#else
  Setup_DebugPrintln("init OLED_NON");
  myoled = new OLED_NON;
  displaystate = false;
#endif // #ifdef OLED_MODE
  Setup_DebugPrintln("Display state:");
  Setup_DebugPrintln(displaystate);

  delay(2500);
}

//_____________________ loop()___________________________________________

void loop()
{
  if ( displayfound )
  {
    myoled->update_oledtextdisplay();
  }
  else
  {
    Serial.print("Display not found");
  }
}
